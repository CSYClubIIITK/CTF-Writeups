# John Will Triumph

**Author: Harsh Iyer**
**Points: 300**
**Difficulty: Medium**

## Description

WindShine has their own Employee Portal but their Intern has accidentally leaked that the username "fansh" has admin access. The auditor has also given us that the username "employee" exists for testing purposes.

Try to find out what WindShine is hiding from the citizens of Lalavoor!

#### Website [Link](https://portal.windshine.site/)

## Solution

We are given a website link for portal.windshine.site which on first glance seems to be an "Employee Login Portal".

> Let's see what we can make out of it.

When given a website in any CTF challenge, the first approach usually is to first start with the source code, maybe play around with some buttons if present to see what happens in the Network tab, maybe some GET/POST requests to some backend.

In this case however, when we click on the the Login button with placeholder values, we see that it sends a POST request to
`https://employeeportalbackend.harshiyer.workers.dev/login`
with the payload

```json
{
	"username":username,
	"password":password
}
```

Interesting. We are also given the usernames for 2 accounts in the challenge description, `fansh`, which has admin access and `employee`. Let's just keep this information in mind as we proceed forward.

Anyways, since we cant seem to find anything remotely interesting in the bundled Next source code, or any other network requests, lets try directory searching.

One of the most common directory files that are on almost all big websites, is `robots.txt` for site crawlers.
Lets try accessing `portal.windshine.site/robots.txt`

Aha, we see something which is encrypted in some language called Brainfuck. This is the text we find.

`++++++++++[>+>+++>+++++++>++++++++++<<<<-]>>>+++++++++.+++++.++++++.>+++++.<-------------.>+++++++++++++++++.<.<++++++++++++++++++++.>++.+++++.--.>----------------.<----.-------.+++.>-.<++++.<.>++++.>.<++++++++.<++++++++++++++++++.---.--------------.>-------------.>+++++++++++++++++.---------------.+++++++++++++.<+++++++++++++.------.<+++++++++++++++.>>---------------.<++++++.------.+.<------------------.>-------.>+++++++++++++++++.<+++.<+.>+++++++++.>-------------.<-----------------.<++++++++++++.`

Let's use an online brainfuck decoder by dcode to see what it translates to.

We get the following string as the output for the Brainfuck reversal:

`OTZiMzM2OTRjNGJiN2RiZDA3MzkxZTBiZTU0NzQ1ZmI=`

Now, always keep one thing in mind, `If it ends in an =, its probably base64.` You can quote me on that. Anyways, using [CyberChef](https://gchq.github.io/CyberChef/) to reverse the base64, we find the following string.

`96b33694c4bb7dbd07391e0be54745fb`

Now, this looks like some sort of md5/sha hash. Let's try to decrypt the hash, not locally but lets use websites for it. I like to use a website called [hashes.com](https://hashes.com/en/decrypt/hash) to decrypt anything related to possible md5/sha hashes.

So, without further ado, lets use that here.

![Decrypt hash](image-1.png)

And upon reversing the hash, it returns to us the following string.
`password456`

This looks like it could be the password to one of the accounts given in the challenge description.

Let's try our luck with the username `fansh`.
It doesnt work. Who wouldve guessed.

Anyways, lets try with the username `employee`.
And this time, it works!

```json
{
  "username": "employee",
  "password": "password456"
}
```

is a valid combination for logging into the WindShine Employee Portal.

We are greeted with a welcome page which looks like this.
![Dashboard](image.png)

Well, nothing super interesting here. Let's see how they are actually keeping me logged in, maybe its in the localstorage, maybe session or cookies, who knows?

Glancing at the Local Storage, it looks empty for the most part.

However, the cookies tab has something interesting in it.

![Cookies](image-2.png)

There is a key with the name `token` and the value `ey.......`

Now, while there is some prior beginner level Authentication knowledge required here, you can do a quick google search to find out that the value represents a JSON Web Token (JWT) which are commonly used for authentication and verifiying credibility.

As I write this writeup, the JWT I was issued has the following value:

`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImVtcGxveWVlIiwiZXhwIjoxNzMyMzUxMTE3fQ.CntKmaqHpGzQMjNfsaMcHjVaf6XncHRbA23ddlXEBbY`

Thing with JSON Web Tokens are, the payloads are publically visible, but you need a secret code to sign the updated payload, to make sure that the token is credible, and that is usually done by the backend which knows the secret code.

That was JWT 101 but let's actually use a tool to view the payload for this specific JWT.

There is a very useful website called [jwt.io](https://jwt.io/) for this exact same purpose.

Pasting our JWT in there, we get the below output.

![jwt.io](image-3.png)

As we can see, there are always 3 parts to a JWT.

- The HEADER
- The PAYLOAD
- The SIGNATURE

The payload is the data that is actually used by the backend once it verifies the signature is legit using the 3rd part, the SIGNATURE.

Now, we can self sign the keys but unless it matches with the secret on the backend, we will be unable to get our token verified.

(Un)Thankfully for us, there is a very famous brute forcing tool called **John the Ripper**, that can also, brute force JWT Signatures.

The method for bruteforcing the signatures using john is as follows

> - First put the jwt in a file called jwt.txt
> - Then run the command **`john jwt.txt`**

That's how easy it is.

Let's see it in action.

I have made a file called jwt.txt with the text as the JWT itself.
![nano](image-4.png)

Now, lets run john on it.

![John](image-5.png)

Running john, we find that the signature is the string `summer05`. Now that we have the signature, that means we can self sign the keys with any payload we want and the backend will think no wrong about it.

Well, thats all we wanted! So lets update the username of the payload to `fansh` which apparently has admin access and update the signature section on jwt.io to `summer05`.

![Final](image-6.png)

We get the following JWT.
`eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VybmFtZSI6ImZhbnNoIiwiZXhwIjoxNzMyMzUxMTE3fQ.E01NG6HRsFNyfliNx_OoDxq_uX7uehFHRYXVTnKZE1E
`

Now, lets replace the JWT in our cookies with this one and hit a simple refresh, making the backend think that its `fansh` logging in.

![Final Result](image-7.png)

And there we have it! Congratulations for solving it and hope you know more know than you did 10 minutes ago.

### **Flag: `cyberarc{1nTeRn_S0_DuMb}`**
